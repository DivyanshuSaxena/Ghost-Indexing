% Chapter Template

\chapter{Index Creation: In Graph Index Structure} % Main chapter title

\label{Chapter 3} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

Now that we are all set with the basic development environment we can start thinking about the structure of our in Graph index data structure and how to create it. Instead of innovating more on the structure side we decided to implement the already popularised index structures inside the graph database and observe the performance changes followed by error analysis over it. So creating index structure inside the graph DB is the next natural step to follow. This chapter gives a detailed explanation of the same.


\section{Choice of Index}
Essentially, most of the popularly used index structures used are either graphs or can be modeled as graphs. For example B-Tree and R-Tree are trees (a type of graphs. Hash indexes too can be seen as a trees with a single internal node having a leaf-child corresponding to each possible value of the hash function even if they are not graphs in the true sense of the word. This means that in a graph database it is quite natural to store them within the graph rather than keeping them as separate independent structures.\\\\
The choice of the index structure to be included in the graph is mainly based on maximising the its utility with a minimum increase in the size of the graph. Therefore, B-Trees and B+ Trees seems to be a reasonable choice. They can have varied depths based on the size of the data being indexed and can be used for answering range queries unlike hash indexes. For example, consider a query requiring us to return all people with age between 20 and 50. If we use a B-Tree index, we can traverse the index tree in a BFS manner keeping only the relevant nodes for further traversal and discarding the others until we finally reach the records. While for Hash indexes, this is not possible. We will have to iterate over all the ages from 20 to 50, and find the records corresponding to each age individually. This though seemingly not so bad in performance however if there are many values for ages with no records then the hash indexes perform really bad. Moreover, consider the extended version of the problem where instead  of age, we only have access to the Date of Birth of the people (i.e. finer granularity on the record values) and the index is present on this value. In this case the the hash function performance degrades considerably as the iteration is now required over all days lying in the span of 30 years whereas the performance of the B-Tree index remains the same.

\section{Construction of B-Tree/B+ Tree Index}

The scope of our work involves creating a framework on top the gremlin query language to create and use B-Tree indexes. However writing B-Tree directly in Gremlin would be really slow to execute. Since we do not need to handle update and modifications in the data, one alternative is to implement the B-tree in some other fast programming language, traverse the tree to determine what all new vertices and edges need to be created in the graph DB, express it in a gremlin script and execute the script. This way we can introduce optimizations for minimizing the number of fetches of vertices and edges in gremlin.\\\\
C++ was chosen as the language for creating the index and traversing it. Since the B-Tree index has an edge to each data vertex on which the index has been created, the generated gremlin script must have twice the number of lines as the data vertices (one for fetching the data vertex and another for connecting it to the index) in addition to the creation of index vertices and index\_vertex-index\_vertex edges (depending on the maximum branching factor chosen for the B-Tree). Thus, the size of the script would be really large for even moderate sized data. For example, the index generation script on a 13.8 MB file containing the 131,566 posts of a social network dataset (generated using LDBC) had 266,039 lines when the maximum branching factor was set to 201. The execution of this script was tried multiple times with inclusion of improvements like use of composite indexes while fetching data vertices, adding intermittent commits and freeing of redundant program variables. However it never completed in 2 days time (tested on Baadal Virtual machine with 32 GB ram, 8 cores).\\\\
The need to introduce improvements like reducing the number of fetches of vertices and using gremlin internal optimizations was felt. One way for this was to run the process of index creation in loops rather than having individual query for each data item (so that the gremlin interpreter can contribute something to the improvements). Since each data item is unique, the only good way to implement this was to have all the edge creations (\textit{INDEX\_EDGES} and \textit{INDEX\_DATA\_EDGES}) needed in a csv file having the id of one vertex against that of another. The creation of these edge links can thus be run in a loop. Another factor introduced through this was sorting the edges creation csv files on the ids of the column having fewer distinct values. This helped us to prevent the extra fetching of the same vertex again and again. When run on Janus Graph with batch loading on, the above index creation successfully completed in \textasciitilde 3 minutes. When tested on a file with 1,003,605 posts, the execution completed in \textasciitilde 17 minutes on aryabhata (128 GB ram, 32 cores).\\\\

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Machine} & \textbf{No. of Vertices} & \textbf{Loading Time} & \textbf{Loading Time}\\
& & (gremlin queries) & (csv files)\\
\hline
& & &\\
Baadal & 131,566 & > 2 days & \textasciitilde 3 min \\
(32 GB, 8 cores) & & & \\
\hline
& & &\\
Aryabhata & 1,003,605 & - & \textasciitilde 17 min \\
(128 GB, 32 cores) & & & \\
\hline
\end{tabular}
\end{center}
$\:$\\
Other index tree structures can be created in a similar way. We have created B+ Tree by making small changes to the code which was used to create the B-Tree. The major change is addition of chain-links (\textit{NEXT\_LEAF\_EDGE}) between leafs which offer a possibility of speeding up the range queries.

\section{Super Index}
To be able to use an index tree for speeding queries, we must first be able to quickly access its root vertex. This creates the need of having an index on the root of all index trees. We call this structure the super index.
\\\\
Our super-index is just a single vertex which has outgoing vertices to all index roots. This edge has the name of the index, property of indexing and type of index (B-Tree/B+ Tree). Keeping the metadata of the index on the edge is useful as we do not need to go the index to know whether we would require to use that index for a particular query. Our program creates the super-index while adding the \textit{Management} data for index creation. The edges from super-index to index are created while creating the index tree.
\\\\
With the super-index, our problem of being able to quickly reach all index roots reduces to just accessing the super-index vertex. One option is to store the vertex-id of this root vertex. However we cannot store this data on the graphdb. So, we should create the super-index root with a special id, like 1 (though custom vertex ids might not be allowed for all Graph DBs). The other way is to give an attribute to this vertex on which a composite index is present. We have used this method. The attribute is \textit{index\_id} and the value is $-1$.