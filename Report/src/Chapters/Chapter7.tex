% Chapter Template

% Chapter Template

\chapter{Conclusion} % Main chapter title

\label{Chapter 7} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

In this chapter we briefly summarize our contributions and put forth several possible future directions for the project that the further extensions might be based on.

\section{Key Contributions}
A key contribution of our work is that it serves as a proof-of-concept showing that in database index structures can be as efficient as the state of the art elastic search indexes. This also in some sense offers a better stability of the complete system by reducing a moving component of a third party application and thus reducing a large number of places where frequent faults or crashes can occur. Not only stability, this concept also offers a very vast flexibility to the user in terms of the design of index structure, which was previously restricted to what is available in elastic search or any other third party indexing application.\\
\\
With the introduction of rewrite engine we can now in fact take a simple user gremlin query and optimize it ourselves to use the in database/graph index structures if available, which also makes our index structures equally easy to use like any other indexing mechanism like elastic search or solr. This work also opens up a much larger new area for any audience willing to try a new innovative index structure and they will be only restricted by the fact that their index must be representable as a graph. We already support the pre-implemented versions of B-Tree and B+ Tree index structures for the aforementioned infrastructure which are one of the most common index structures in the databases community.

\section{Further Extensions}
This section describes in brief some of the several possible future directions directions of this work.

\paragraph{Selecting amongst multiple available indexes}
$\:$\\
We currently select the first possible usage of index to rewrite the given query. But, suppose there are many indexes with different parameters on same key, how to select one? An improvement over this would be to add a metric for selecting the best index amongst a variety on indexes available on different attributes of a gremlin query. 

\paragraph{Extending to other databases}
$\:$\\
Also, this work is clearly not restricted to a single graph database but applies to a large variety of them. Extension implementations of the same for other Graph DBs like Neo4J is likely to generalize these kind of indexes even further. Converting the system into a easy to use plugin for Janusgraph/Neo4J is a direct way popularizing this kind of index in the community.

\paragraph{Adding more index structures or a GiST}
$\:$\\
Expanding this work into something where any user can be allowed to just add code to a few functions to introduce another kind of new/novel index can greatly accelerate the usage of this kind of index structures. Another possible way to add the power of a generalized search index would be to implement something like the GiST (Generalized Search Tree) mentioned by Hellerstein et. al \cite{GiST}.

\paragraph{Other kinds of traversals}
$\:$\\
Storing index structures along with the data opens multiple new avenues which can be exploited to optimize the execution of queries on Graph DBs. Apart from the traditional index-to-data traversal, data-to-index and index-to-index movements too are possible now.

\subparagraph{Data to Index}
$\:$\\
Moving from Data to Index can help us easily determine the key on which the index is based given the data vertex. This might at first not seem to be really useful owing to the fact that if the indexing key is already a property of the vertex, then once we have the vertex, we can directly find its value instead of going to the index vertex and adding one extra vertex fetch.\\
\\
However, consider the case where the index is present on the some aggregation of keys rather than directly the key. For example an index on the percentile of marks received by a student can help to trivially compute his percentile which in the absence of such an index would involve multiple vertex fetches.

\subparagraph{Index to Index}
$\:$\\
Another possible extension to this is the \textbf{Index-to-Data-to-Index} traversal which can help us answer queries like what percentile of salary is being received by the students with top x percentile marks.\\
\\
In this kind of queries, an execution can be framed that using the index structures, filters the data swiftly to get to a specific set of vertices/data nodes. This execution can then use the idea from the data to index traversal to answer the aggregation queries on this filtered set of nodes.\\
\\
Creating/obtaining a set of workloads / benchmark specifically to observe the effects of these kind of optimizations (and novel use of index structures) is an issue one might have address before jumping right into these kinds of executions/traversal though.

\paragraph{Creation of  index structures automatically based on workload}
$\:$\\
Analysis of workload of a set of queries can help in further refining the indexing in Graph DBs. We can suggest suitable indexes to be created internally without the knowledge of the user and use these indexes to automatically modify the queries for making use of these indexes. Apart from simple suggestion of indexes based on workloads, this requires analysis of each index to judge whether it offers a good trade-off in terms of performance improvement over increase in size of the graph (due to the additional vertices and edges we add to accommodate the index structure).