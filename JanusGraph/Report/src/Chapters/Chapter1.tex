% Chapter 1

\chapter{Introduction} % Main chapter title

\label{Chapter1} % For referencing the chapter elsewhere, use \ref{Chapter1} 

%----------------------------------------------------------------------------------------

% Define some commands to keep the formatting separated from the content 
\newcommand{\keyword}[1]{\textbf{#1}}
\newcommand{\tabhead}[1]{\textbf{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\file}[1]{\texttt{\bfseries#1}}
\newcommand{\option}[1]{\texttt{\itshape#1}}

%----------------------------------------------------------------------------------------

\section{Motivation}
NoSQL and Graph databases are alternatives to the already existing SQL approaches used in web and cloud applications. They have recently gained a wide spread acceptance, both in industry and academia. This has been due the their ability to handle an increasing scale of operations and the fact that they allow data to be stored in a way it is modeled. \\
\\
These databases do support indexes but require a separate index backend to create and maintain this index. This not only adds more moving components to the database but also hampers the flexibility to use the set of index structures offered by the application alone. This separation of index, from the data, at an application level causes inefficiencies in its usage. This is due to the inter-application overheads involved in the communictaion between the graph database store and the index backend. Hence, exploiting the flexible schema of graph databases, we have devised a way to store the index along with the data, and reduce these additional overheads.

%----------------------------------------------------------------------------------------

\section{Approach}
Schema flexibility in Graph databases allows us to "rewire" a graph in the database by introducing new vertices and edges/relationships between these and original vertices. We create these new, or "ghost" edges and vertices, based on their utility in making the queries faster. These vertices and edges should ideally be invisible to the end-user and play the role of an \textit{index} in these graph databases. \\
\\
These will allow us to perform faster traversal in the graph and hence would speed up the queries we wish to run on the graph. We construct these elements and put them as a layer in the graph database itself, as "ghost" nodes and edges. Clearly, this kind of rewiring is going to bloat up the size of the graph, hence we must chose the vertices and edges to be added carefully. This decision is should be made on the basis of a set of static query workloads given initially. Currently we do not have a metric to base our decision regarding the choice of the index but use intuition for all further experiments stated in the paper.\\
\\
Considering this flexibility of the graph, a natural way to introduce powerful indexing capabilities within the graph is to store the index itself as a layer in the graph. We utilize the fact that most of the traditional indexes can be represented as trees (for eg B-Tree), which are essentially graphs. For instance, it is possible to store a multi-dimensional index structure such as R-Tree simply in the graph database starting from linking vertices which have overlapping bounding boxes, and going on to construct multiple layers of this relationship in the same manner as a traditional R-Tree. \\
\\
Finally, to understand the impact of these methods, we need to run test on a benchmark. We choose the LDBC's  \cite{benchmark} (Linked Data Benchmark Council) Business Intelligence Workload which consists a various complex structured queries for analyzing the behaviour of various parts of a social network. These workloads help us highlight the effect of our methods on the performance. 

\section{Choice of Benchmark}
LDBC (Linked Data Benchmark Council)  \cite{benchmark} is an organization that develops benchmarks that allow various Graph Database management systems to be tested for their capabilities and their performance. We use the Social Network benchmark developed by them. This benchmark has vertices and edges in the structure of a typical social network i.e. users with details about them, people they know, their posts and likes and comments on posts. It also has a set of both interactive and business intelligence queries that operate on this data. Also it has a data generator package which can create social network databases of varied sizes.\\
\\
Social Networks are one of the best examples of applications of Graph databases and therefore they form a great choice for queries which can involve a given number of hops (example a 2 hop from a person would give the people known to the people he knows). The indexes we are creating can thus be tested for efficiency by cutting down on the number of such hops. So social networks are a good choice for benchmarking.\\
\\
LDBC SNB workload has some really good properties that allows us to create synthetic data which closely mimics the data from real social networks. It enforces on the network structure the power law distribution in terms of various properties as well as the short diameters of the graph that are generally common in social networks. It is also generates property values which are realistic in nature and generated from correlated value distributions of these properties. Temporal correlations and presence of flash mobs is also something that makes this a really valuable benchmark for any system that is to work in a real world scenario.\\
\\
For our testing, we only deal with the Business Intelligence queries of the Social Network benchmark. This consists of complex structured query workloads.  Most of these queries require us to find and group vertices that satisfy certain given constraints. Since we are using the Gremlin query language, we had to convert these queries into gremlin and run them on the database loaded by us. These conversions can be found in our java project codebase \cite{repo} .

% \begin{flushright}
% Guide written by ---\\
% Sunil Patel: \href{http://www.sunilpatel.co.uk}{www.sunilpatel.co.uk}\\
% Vel: \href{http://www.LaTeXTemplates.com}{LaTeXTemplates.com}
% \end{flushright}
