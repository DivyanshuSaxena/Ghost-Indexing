1.
MATCH (p:Person {id:"@1"})
WITH p
MATCH (p)-[path:KNOWS*1..3]->(f:Person {firstName:"@2"})
WITH f, min(length(path)) as distance
MATCH (f)-[:IS_LOCATED_IN]->(fCity:City)
OPTIONAL MATCH (f)-[studyDet:STUDY_AT]->(u:University)-[:IS_LOCATED_IN]->(uc:City)
WITH f, collect( CASE u.name
                    WHEN null THEN null
                    ELSE [u.name, studyDet.classYear, uc.name]
                 END)
        AS universities, fCity, distance
OPTIONAL MATCH (f)-[workDet:WORK_AT]->(c:Company)-[:IS_LOCATED_IN]->(cc:City)
WITH f, collect( CASE u.name
                    WHEN null THEN null
                    ELSE [c.name, workDet.workFrom, cc.name]
                 END)
        AS companies, universities, fCity, distance
RETURN f,companies, universities, fCity, distance
ORDER BY distance ASC, f.lastName ASC, toInteger(f.id) ASC
LIMIT 20

/**
*   - WITH f, min(length(path)) as distance: Aggregate by f
*   - Push LIMIT up to optimize the query
*/

-----------------------------------------------------------------------------------------

2.
MATCH (p:Person {id:"@1"})
WITH p
MATCH (p)-[:KNOWS]->(f:Person)
WITH p,f
MATCH (f)<-[:HAS_CREATOR]-(m:Message)
WHERE m.creationDate <= "@2"
RETURN
    f.id AS Person.id,
    f.firstName AS Person.firstName,
    f.lastName AS Person.lastName,
    m.id,
    CASE size(m.content) > 0
        WHEN true THEN m.content
        ELSE m.imageFile"
    END AS messageContent,
    m.creationDate
ORDER BY m.creationDate DESC, toInteger(m.id) ASC
LIMIT 20


